// ============================== start_kernel
(init\main.c)
asmlinkage __visible void __init start_kernel(void)
{
	char *command_line;
	char *after_dashes;

	/*
	 * Need to run as early as possible, to initialize the
	 * lockdep hash:
	 */
	lockdep_init();                                                // 初始化两个hashtable，设置 lockdep_initialized = 1;  (static int lockdep_initialized;)
	                                                               // --------- static struct list_head classhash_table[CLASSHASH_SIZE];  1 << 12 , 4K 大小
																   // --------- static struct list_head chainhash_table[CHAINHASH_SIZE];  1 << 15 , 32K 大小
	set_task_stack_end_magic(&init_task);                          // 给 init_task 任务栈尾添加 magic (STACK_END_MAGIC:0x57AC6E9D)
	smp_setup_processor_id();                                      // 设置__cpu_logical_map[]数组，设置启动的 cpu，并输出信息： 
	                                                               // --------- 从 cp15 获取硬件信息，smp，设置 __cpu_logical_map[] 数组，设置当前使用 cpu0 启动
	                                                               // --------- 输出 "Booting Linux on physical CPU 0x%x\n"
	debug_objects_early_init();                                    // debug_objects 初始化
	                                                               // --------- 初始化 &obj_hash[i].lock，&obj_static_pool[i].node 添加到 &obj_pool 链表中

	/*
	 * Set up the the initial canary ASAP:
	 */
	boot_init_stack_canary();                                      // 产生一个随机数，赋值给当前(任务栈指针，指向的任务，的stack_canary) current->stack_canary，__stack_chk_guard
	                                                               // -------- current = get_current() = current_thread_info()->task
																   // -------- current_thread_info() = (current_stack_pointer & ~(THREAD_SIZE - 1)) = ( asm ("sp") & ~(THREAD_SIZE - 1))
	cgroup_init_early();                                           // 初始化 cgroups
	                                                               // -------- 初始化 struct cgroup_root cgrp_dfl_root;
																   // -------- 初始化 init_task.cgroups，使用 init_css_set
	local_irq_disable();                                           // 关闭中断，
	                                                               // -------- 修改 cpsr，cpsid 指令
	early_boot_irqs_disabled = true;                               // 修改全局变量
	                                                               // -------- extern bool early_boot_irqs_disabled

/*
 * Interrupts are still disabled. Do necessary setups, then
 * enable them
 */
	boot_cpu_init();                                               // 向四个 cpumask 中写入当前 cpu 状态
	                                                               // -------- cpu_online_bits，cpu_active_bits，cpu_present_bits，cpu_possible_bits
	page_address_init();                                           // 高端内存使用 hashtable 管理，初始化 128 个 page_address_htable 数组
	pr_notice("%s", linux_banner);                                 // 输出 linux_banner
	                                                               // -------- 输出 Linux version 4.1.15 (root@dell) (gcc version 6.3.1 20170109 (Linaro GCC 6.3-2017.02) ) #1 SMP PREEMPT Sun Jun 30 03:59:10 CST 2019
																   
	setup_arch(&command_line);                                     // 初始化 init_mm, boot_command_line，mdesc, 内存，电源，设备树，DT_cpu。  >>>>>>>>>>>>>>>>>

	mm_init_cpumask(&init_mm);                                     // 清零 init_mm->cpu_vm_mask_var (bitmap)中的 cpu 对应的位
	setup_command_line(command_line);                              // 设置三个静态变量，saved_command_line，initcall_command_line，static_command_line
	setup_nr_cpu_ids();                                            // 设置全局变量 nr_cpu_ids 为 cpu 个数
	setup_per_cpu_areas();                                         // 初始化 setup_per_cpu_areas
	smp_prepare_boot_cpu();	/* arch-specific boot-cpu hooks */

	build_all_zonelists(NULL, NULL);                               // 创建 zonelists，设置 vm_total_pages
	page_alloc_init();                                             // 给每个 cpu_chain 注册 notifier

	pr_notice("Kernel command line: %s\n", boot_command_line);     // 打印 boot_command_line
	parse_early_param();                                           // 分析 parame
	after_dashes = parse_args("Booting kernel",                    // 
				  static_command_line, __start___param,
				  __stop___param - __start___param,
				  -1, -1, &unknown_bootoption);
	if (!IS_ERR_OR_NULL(after_dashes))
		parse_args("Setting init args", after_dashes, NULL, 0, -1, -1,
			   set_init_arg);

	jump_label_init();                                                    // 初始化跳转表

	/*
	 * These use large bootmem allocations and must precede
	 * kmem_cache_init()
	 */
	setup_log_buf(0);                                                     // 初始化 log_buf
	pidhash_init();                                                       // 分配 pidhash 空间，初始化 pidhash 头
	vfs_caches_init_early();                                              // 初始化 dentry_hashtable，inode_hashtable，使用 alloc_large_system_hash 函数
	sort_main_extable();                                                  // 排序 异常表
	trap_init();                                                          // 空
	mm_init();                                                            // 内存初始化

	/*
	 * Set up the scheduler prior starting any interrupts (such as the
	 * timer interrupt). Full topology setup happens at smp_init()
	 * time - but meanwhile we still have a functioning scheduler.
	 */
	sched_init();                                                         // 初始化各个 cpu 的运行队列，时钟，信号，权重，调度类，开启调度器，修改调度器标志 (申请内存使用 kzalloc)
	/*
	 * Disable preemption - early bootup scheduling is extremely
	 * fragile until we cpu_idle() for the first time.
	 */
	preempt_disable();                                                    // 抢占失效
	if (WARN(!irqs_disabled(),
		 "Interrupts were enabled *very* early, fixing it\n"))
		local_irq_disable();                                              // 关中断
	idr_init_cache();                                                     // 申请内存赋值给 idr_layer_cache
	rcu_init();                                                           // 初始化 RCR

	/* trace_printk() and trace points may be used after this */
	trace_init();                                                         // 申请内存，初始化 trace，注册 notifer

	context_tracking_init();
	radix_tree_init();                                                    // 初始化 radix_tree，设置 radix_tree_node_cachep
	/* init some links before init_ISA_irqs() */
	early_irq_init();
	init_IRQ();
	tick_init();
	rcu_init_nohz();
	init_timers();
	hrtimers_init();
	softirq_init();
	timekeeping_init();
	time_init();
	sched_clock_postinit();
	perf_event_init();
	profile_init();
	call_function_init();
	WARN(!irqs_disabled(), "Interrupts were enabled early\n");
	early_boot_irqs_disabled = false;
	local_irq_enable();                                                    // 初始化 irq，时钟，开启 irq

	kmem_cache_init_late();

	/*
	 * HACK ALERT! This is early. We're enabling the console before
	 * we've done PCI setups etc, and console_init() must be aware of
	 * this. But we do want output early, in case something goes wrong.
	 */
	console_init();                                                          // 初始化控制台，设置 ops，添加到数组
	if (panic_later)
		panic("Too many boot %s vars at `%s'", panic_later,
		      panic_param);                                                  // panic 处理

	lockdep_info();                                                          // 输出信息 "Lock dependency validator: Copyright (c) 2006 Red Hat, Inc., Ingo Molnar\n"

	/*
	 * Need to run this when irqs are enabled, because it wants
	 * to self-test [hard/soft]-irqs on/off lock inversion bugs
	 * too:
	 */
	locking_selftest();                                                      // 测试

#ifdef CONFIG_BLK_DEV_INITRD
	if (initrd_start && !initrd_below_start_ok &&
	    page_to_pfn(virt_to_page((void *)initrd_start)) < min_low_pfn) {
		pr_crit("initrd overwritten (0x%08lx < 0x%08lx) - disabling it.\n",
		    page_to_pfn(virt_to_page((void *)initrd_start)),
		    min_low_pfn);
		initrd_start = 0;                                                    // initrd 检查
	}
#endif
	page_ext_init();
	debug_objects_mem_init();                                                // 
	                                                                         // kmem_cache_create，kmem_cache_destroy
	kmemleak_init();
	setup_per_cpu_pageset();
	numa_policy_init();
	if (late_time_init)
		late_time_init();
	sched_clock_init();                                                      // 所有 cpu 调度时钟结构初始化 (struct sched_clock_data)
	calibrate_delay();                                                       // 输出 "Calibrating delay loop (skipped), value calculated using timer frequency.. 48.00 BogoMIPS (lpj=240000)"
                                                                             // 设置 loops_per_jiffy
	pidmap_init();                                                           // 创建 init_pid_ns.pid_cachep (struct pid_namespace)
	anon_vma_init();                                                         // 创建 anon_vma_cachep, anon_vma_chain_cachep (struct kmem_cache)
	acpi_early_init();
#ifdef CONFIG_X86
	if (efi_enabled(EFI_RUNTIME_SERVICES))
		efi_enter_virtual_mode();
#endif
#ifdef CONFIG_X86_ESPFIX64
	/* Should be run before the first non-init thread is created */
	init_espfix_bsp();
#endif
	thread_info_cache_init();                                                // 创建 thread_info_cache (struct kmem_cache)
	cred_init();                                                             // 创建 cred_jar (struct kmem_cache)
	fork_init();                                                             // 创建 task_struct_cachep (init_task.signal->rlim), 设置 init_task.signal->rlim[RLIMIT_NPROC].rlim_cur
	                                                                         //                                                                                            .rlim_max
																			 //                                                        init_task.signal->rlim[RLIMIT_SIGPENDING] =  init_task.signal->rlim[RLIMIT_NPROC];
	proc_caches_init();                                                      // 创建 sighand_cachep，signal_cachep，files_cachep，fs_cachep，mm_cachep，vm_area_cachep，nsproxy_cachep
	buffer_init();                                                           // 创建 bh_cachep
	key_init();
	security_init();
	dbg_late_init();                                                         // 注册命令列表，断点 (early: 分析命令，添加到数组)
	vfs_caches_init(totalram_pages);                                         // 创建 cache，注册根文件系统并挂载，创建 bdev文件系统并挂载，创建 chrdev 文件系统
	signals_init();                                                          // 创建 sigqueue_cachep
	/* rootfs populating might need page-writeback */
	page_writeback_init();
	proc_root_init();                                                        // 初始化 proc
	nsfs_init();                                                             // 挂载 nsfs 
	cpuset_init();                                                           // 注册 cpuset 文件系统
	cgroup_init();                                                           // 注册 cgroup 文件系统
	taskstats_init_early();                                                  // 创建 taskstats_cache，初始化
	delayacct_init();                                                        // 初始化 init_tsk 的 delayacct

	check_bugs();

	acpi_subsystem_init();
	sfi_init_late();

	if (efi_enabled(EFI_RUNTIME_SERVICES)) {
		efi_late_init();
		efi_free_boot_services();
	}

	ftrace_init();

	/* Do the rest non-__init'ed, we're now alive */
	rest_init();
}

// --------
static noinline void __init_refok rest_init(void)
{
	int pid;

	rcu_scheduler_starting();                                              // 修改 rcu_scheduler_active = 1;
	smpboot_thread_init();                                                 // 注册通知 smpboot_thread_notifier
	/*
	 * We need to spawn init first so that it obtains pid 1, however
	 * the init task will end up wanting to create kthreads, which, if
	 * we schedule it before we create kthreadd, will OOPS.
	 */
	kernel_thread(kernel_init, NULL, CLONE_FS);
	numa_default_policy();
	pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);
	rcu_read_lock();
	kthreadd_task = find_task_by_pid_ns(pid, &init_pid_ns);
	rcu_read_unlock();
	complete(&kthreadd_done);

	/*
	 * The boot idle thread must execute schedule()
	 * at least once to get things moving:
	 */
	init_idle_bootup_task(current);
	schedule_preempt_disabled();
	/* Call into cpu_idle with preempt disabled */
	cpu_startup_entry(CPUHP_ONLINE);                                       // 0 号进程 idle，1 号进程 kernel_init，2 号进程 kthreadd
}

// --------
static int __ref kernel_init(void *unused)
{
	int ret;

	kernel_init_freeable();                                                // =========================
	/* need to finish all async __init code before freeing the memory */
	async_synchronize_full();
	free_initmem();
	mark_rodata_ro();
	system_state = SYSTEM_RUNNING;
	numa_default_policy();

	flush_delayed_fput();

	if (ramdisk_execute_command) {
		ret = run_init_process(ramdisk_execute_command);                 // 运行 ramdisk_execute_command
		if (!ret)
			return 0;
		pr_err("Failed to execute %s (error %d)\n",
		       ramdisk_execute_command, ret);
	}

	/*
	 * We try each of these until one succeeds.
	 *
	 * The Bourne shell can be used instead of init if we are
	 * trying to recover a really broken machine.
	 */
	if (execute_command) {
		ret = run_init_process(execute_command);                        // 运行 execute_command (init=)
		if (!ret)
			return 0;
		panic("Requested init %s failed (error %d).",
		      execute_command, ret);
	}
	if (!try_to_run_init_process("/sbin/init") ||                       // 运行文件系统
	    !try_to_run_init_process("/etc/init") ||
	    !try_to_run_init_process("/bin/init") ||
	    !try_to_run_init_process("/bin/sh"))
		return 0;

	panic("No working init found.  Try passing init= option to kernel. "
	      "See Linux Documentation/init.txt for guidance.");
}

// --------
static noinline void __init kernel_init_freeable(void)
{
	/*
	 * Wait until kthreadd is all set-up.
	 */
	wait_for_completion(&kthreadd_done);

	/* Now the scheduler is fully set up and can do blocking allocations */
	gfp_allowed_mask = __GFP_BITS_MASK;

	/*
	 * init can allocate pages on any node
	 */
	set_mems_allowed(node_states[N_MEMORY]);
	/*
	 * init can run on any cpu.
	 */
	set_cpus_allowed_ptr(current, cpu_all_mask);

	cad_pid = task_pid(current);

	smp_prepare_cpus(setup_max_cpus);

	do_pre_smp_initcalls();
	lockup_detector_init();

	smp_init();
	sched_init_smp();

	do_basic_setup();                                                          // ======================

	/* Open the /dev/console on the rootfs, this should never fail */
	if (sys_open((const char __user *) "/dev/console", O_RDWR, 0) < 0)
		pr_err("Warning: unable to open an initial console.\n");

	(void) sys_dup(0);
	(void) sys_dup(0);
	/*
	 * check if there is an early userspace init.  If yes, let it do all
	 * the work
	 */

	if (!ramdisk_execute_command)
		ramdisk_execute_command = "/init";

	if (sys_access((const char __user *) ramdisk_execute_command, 0) != 0) {
		ramdisk_execute_command = NULL;
		prepare_namespace();
	}

	/*
	 * Ok, we have completed the initial bootup, and
	 * we're essentially up and running. Get rid of the
	 * initmem segments and start the user-mode stuff..
	 *
	 * rootfs is available now, try loading the public keys
	 * and default modules
	 */

	integrity_load_keys();
	load_default_modules();
}

// --------
static void __init do_basic_setup(void)
{
	cpuset_init_smp();
	usermodehelper_init();
	shmem_init();                                                     // 注册 shmem fs
	driver_init();                                                    // =======================
	init_irq_proc();                                                  // 向 proc 注册 irq
	do_ctors();
	usermodehelper_enable();
	do_initcalls();                                                   // 依次执行所有的 initcall
	random_int_secret_init();
}

// --------
void __init driver_init(void)
{
	/* These are the core pieces */
	devtmpfs_init();                                                 // 注册 dev fs
	devices_init();                                                  // 创建 devices (kset)，dev, block, char (kobject)
	buses_init();                                                    // 创建 bus(kset), system (kset)
	classes_init();                                                  // 创建 class (kset)
	firmware_init();                                                 // 创建 firmware (kobject)
	hypervisor_init();                                               // 创建 hypervisor (kobject)

	/* These are also core pieces, but must come after the
	 * core core pieces.
	 */
	platform_bus_init();                                             // 注册 platform_bus，platform_bus_type，注册 notifer
	cpu_dev_init();                                                  // cpu 子系统注册，cpu 设备注册
	memory_dev_init();                                               // memory 子系统注册
	container_dev_init();                                            // 容器子系统注册
	of_core_init();                                                  // 注册设备树 kset，添加所有节点设备 kobject，创建 bin_file 
}









