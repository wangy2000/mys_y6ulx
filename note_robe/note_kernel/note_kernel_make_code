// ============================== start_kernel
(init\main.c)
asmlinkage __visible void __init start_kernel(void)
{
	char *command_line;
	char *after_dashes;

	/*
	 * Need to run as early as possible, to initialize the
	 * lockdep hash:
	 */
	lockdep_init();                                                // 初始化两个hashtable，设置 lockdep_initialized = 1;  (static int lockdep_initialized;)
	                                                               // --------- static struct list_head classhash_table[CLASSHASH_SIZE];  1 << 12 , 4K 大小
																   // --------- static struct list_head chainhash_table[CHAINHASH_SIZE];  1 << 15 , 32K 大小
	set_task_stack_end_magic(&init_task);                          // 给 init_task 任务栈尾添加 magic (STACK_END_MAGIC:0x57AC6E9D)
	smp_setup_processor_id();                                      // 设置__cpu_logical_map[]数组，设置启动的 cpu，并输出信息： 
	                                                               // --------- 从 cp15 获取硬件信息，smp，设置 __cpu_logical_map[] 数组，设置当前使用 cpu0 启动
	                                                               // --------- 输出 "Booting Linux on physical CPU 0x%x\n"
	debug_objects_early_init();                                    // debug_objects 初始化
	                                                               // --------- 初始化 &obj_hash[i].lock，&obj_static_pool[i].node 添加到 &obj_pool 链表中

	/*
	 * Set up the the initial canary ASAP:
	 */
	boot_init_stack_canary();                                      // 产生一个随机数，赋值给当前(任务栈指针，指向的任务，的stack_canary) current->stack_canary，__stack_chk_guard
	                                                               // -------- current = get_current() = current_thread_info()->task
																   // -------- current_thread_info() = (current_stack_pointer & ~(THREAD_SIZE - 1)) = ( asm ("sp") & ~(THREAD_SIZE - 1))
	cgroup_init_early();                                           // 初始化 cgroups
	                                                               // -------- 初始化 struct cgroup_root cgrp_dfl_root;
																   // -------- 初始化 init_task.cgroups，使用 init_css_set
	local_irq_disable();                                           // 关闭中断，
	                                                               // -------- 修改 cpsr，cpsid 指令
	early_boot_irqs_disabled = true;                               // 修改全局变量
	                                                               // -------- extern bool early_boot_irqs_disabled

/*
 * Interrupts are still disabled. Do necessary setups, then
 * enable them
 */
	boot_cpu_init();                                               // 向四个 cpumask 中写入当前 cpu 状态
	                                                               // -------- cpu_online_bits，cpu_active_bits，cpu_present_bits，cpu_possible_bits
	page_address_init();                                           // 高端内存使用 hashtable 管理，初始化 128 个 page_address_htable 数组
	pr_notice("%s", linux_banner);                                 // 输出 linux_banner
	                                                               // -------- 输出 Linux version 4.1.15 (root@dell) (gcc version 6.3.1 20170109 (Linaro GCC 6.3-2017.02) ) #1 SMP PREEMPT Sun Jun 30 03:59:10 CST 2019
																   
	setup_arch(&command_line);                                     // 初始化 init_mm, boot_command_line，mdesc, 内存，电源，设备树，DT_cpu。单独文件详细分析

	mm_init_cpumask(&init_mm);                                     // 清零 init_mm->cpu_vm_mask_var (bitmap)中的 cpu 对应的位
	setup_command_line(command_line);                              // 设置三个静态变量，saved_command_line，initcall_command_line，static_command_line
	setup_nr_cpu_ids();                                            // 设置全局变量 nr_cpu_ids 为 cpu 个数
	setup_per_cpu_areas();                                         // 初始化 setup_per_cpu_areas
	smp_prepare_boot_cpu();	/* arch-specific boot-cpu hooks */

	build_all_zonelists(NULL, NULL);                               // ？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？
	page_alloc_init();

	pr_notice("Kernel command line: %s\n", boot_command_line);
	parse_early_param();
	after_dashes = parse_args("Booting kernel",
				  static_command_line, __start___param,
				  __stop___param - __start___param,
				  -1, -1, &unknown_bootoption);
	if (!IS_ERR_OR_NULL(after_dashes))
		parse_args("Setting init args", after_dashes, NULL, 0, -1, -1,
			   set_init_arg);

	jump_label_init();

	/*
	 * These use large bootmem allocations and must precede
	 * kmem_cache_init()
	 */
	setup_log_buf(0);
	pidhash_init();
	vfs_caches_init_early();
	sort_main_extable();
	trap_init();
	mm_init();

	/*
	 * Set up the scheduler prior starting any interrupts (such as the
	 * timer interrupt). Full topology setup happens at smp_init()
	 * time - but meanwhile we still have a functioning scheduler.
	 */
	sched_init();
	/*
	 * Disable preemption - early bootup scheduling is extremely
	 * fragile until we cpu_idle() for the first time.
	 */
	preempt_disable();
	if (WARN(!irqs_disabled(),
		 "Interrupts were enabled *very* early, fixing it\n"))
		local_irq_disable();
	idr_init_cache();
	rcu_init();

	/* trace_printk() and trace points may be used after this */
	trace_init();

	context_tracking_init();
	radix_tree_init();
	/* init some links before init_ISA_irqs() */
	early_irq_init();
	init_IRQ();
	tick_init();
	rcu_init_nohz();
	init_timers();
	hrtimers_init();
	softirq_init();
	timekeeping_init();
	time_init();
	sched_clock_postinit();
	perf_event_init();
	profile_init();
	call_function_init();
	WARN(!irqs_disabled(), "Interrupts were enabled early\n");
	early_boot_irqs_disabled = false;
	local_irq_enable();

	kmem_cache_init_late();

	/*
	 * HACK ALERT! This is early. We're enabling the console before
	 * we've done PCI setups etc, and console_init() must be aware of
	 * this. But we do want output early, in case something goes wrong.
	 */
	console_init();
	if (panic_later)
		panic("Too many boot %s vars at `%s'", panic_later,
		      panic_param);

	lockdep_info();

	/*
	 * Need to run this when irqs are enabled, because it wants
	 * to self-test [hard/soft]-irqs on/off lock inversion bugs
	 * too:
	 */
	locking_selftest();

#ifdef CONFIG_BLK_DEV_INITRD
	if (initrd_start && !initrd_below_start_ok &&
	    page_to_pfn(virt_to_page((void *)initrd_start)) < min_low_pfn) {
		pr_crit("initrd overwritten (0x%08lx < 0x%08lx) - disabling it.\n",
		    page_to_pfn(virt_to_page((void *)initrd_start)),
		    min_low_pfn);
		initrd_start = 0;
	}
#endif
	page_ext_init();
	debug_objects_mem_init();
	kmemleak_init();
	setup_per_cpu_pageset();
	numa_policy_init();
	if (late_time_init)
		late_time_init();
	sched_clock_init();
	calibrate_delay();
	pidmap_init();
	anon_vma_init();
	acpi_early_init();
#ifdef CONFIG_X86
	if (efi_enabled(EFI_RUNTIME_SERVICES))
		efi_enter_virtual_mode();
#endif
#ifdef CONFIG_X86_ESPFIX64
	/* Should be run before the first non-init thread is created */
	init_espfix_bsp();
#endif
	thread_info_cache_init();
	cred_init();
	fork_init();
	proc_caches_init();
	buffer_init();
	key_init();
	security_init();
	dbg_late_init();
	vfs_caches_init(totalram_pages);
	signals_init();
	/* rootfs populating might need page-writeback */
	page_writeback_init();
	proc_root_init();
	nsfs_init();
	cpuset_init();
	cgroup_init();
	taskstats_init_early();
	delayacct_init();

	check_bugs();

	acpi_subsystem_init();
	sfi_init_late();

	if (efi_enabled(EFI_RUNTIME_SERVICES)) {
		efi_late_init();
		efi_free_boot_services();
	}

	ftrace_init();

	/* Do the rest non-__init'ed, we're now alive */
	rest_init();
}


