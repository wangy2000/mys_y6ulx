# ============================================= makefile 包含文件
include scripts/Kbuild.include
-include include/config/auto.conf
-include include/config/auto.conf.cmd
-include include/autoconf.mk
-include include/autoconf.mk.dep
include config.mk
include arch/$(ARCH)/Makefile
include scripts/Makefile.extrawarn

version_h := include/generated/version_autogenerated.h
timestamp_h := include/generated/timestamp_autogenerated.h

# --------------------------------------------- Makefile.build 包含文件
-include include/config/auto.conf
-include $(prefix)/include/autoconf.mk
include scripts/Makefile.uncmd_spl

include scripts/Kbuild.include
kbuild-file := $(if $(wildcard $(kbuild-dir)/Kbuild),$(kbuild-dir)/Kbuild,$(kbuild-dir)/Makefile)
include $(kbuild-file)

include scripts/Makefile.lib

ifneq ($(hostprogs-y)$(hostprogs-m),)
include scripts/Makefile.host
endif

ifneq ($(cmd_files),)
  include $(cmd_files)
endif


# =============================================




config: scripts_basic outputmakefile FORCE
	$(Q)$(MAKE) $(build)=scripts/kconfig $@

%config: scripts_basic outputmakefile FORCE
	$(Q)$(MAKE) $(build)=scripts/kconfig $@

	$(Q)$(MAKE) $(build)=scripts/kconfig $@
	= $(Q)$(MAKE)  -f  $(srctree)/scripts/Makefile.build  obj=scripts/kconfig  mys_imx6ull_14x14_emmc_defconfig
	= conf  -s  --defconfig=arch/arm/configs/mys_imx6ull_14x14_emmc_defconfig  Kconfig


	




# =============================================                                     编译出 scripts/basic/fixdep
scripts_basic:
	$(Q)$(MAKE) $(build)=scripts/basic
	$(Q)rm -f .tmp_quiet_recordmcount

	$(Q)$(MAKE) $(build)=scripts/basic
	= $(Q)$(MAKE)  -f  $(srctree)/scripts/Makefile.build  obj=scripts/basic

# 没有目标所以目标是__build	
__build: $(builtin-target) $(lib-target) $(extra-y)) $(subdir-ym) $(always)

builtin-target := scripts/basic/built-in.o                                        ## 连接产生的目标
lib-target := scripts/basic/lib.a



$(obj)/%.o: $(src)/%.c $(recordmcount_source) FORCE
	$(call cmd,force_checksrc)
	$(call if_changed_rule,cc_o_c)

=
$(obj)/%.o: $(obj)/%.c FORCE
	$(call cmd,force_checksrc)                                                    ## 打印命令，并分析 c 源码语法错误
	$(call if_changed_rule,cc_o_c)                                                ## 如果目标有更新，或者编译命令改变，编译目标，并分析依赖

# ---------------------
cmd = @$(echo-cmd) $(cmd_$(1))

echo-cmd = $(if $($(quiet)cmd_$(1)),
	echo '  $(call escsq,$($(quiet)cmd_$(1)))$(echo-why)';)
# escsq 替换 $1 的 ' 为 '\''

ifeq ($(KBUILD_VERBOSE),2)
why =                                                                        \
    $(if $(filter $@, $(PHONY)),- due to target is PHONY,                    \
        $(if $(wildcard $@),                                                 \
            $(if $(strip $(any-prereq)),- due to: $(any-prereq),             \
                $(if $(arg-check),                                           \
                    $(if $(cmd_$@),- due to command line change,             \
                        $(if $(filter $@, $(targets)),                       \
                            - due to missing .cmd file,                      \
                            - due to $(notdir $@) not in $$(targets)         \
                         )                                                   \
                     )                                                       \
                 )                                                           \
             ),                                                              \
             - due to target missing                                         \
         )                                                                   \
     )

echo-why = $(call escsq, $(strip $(why)))
endif
# KBUILD_VERBOSE = 2 调试才有的功能

# ----------------------
ifneq ($(KBUILD_CHECKSRC),0)
  ifeq ($(KBUILD_CHECKSRC),2)
    quiet_cmd_force_checksrc = CHECK   $<
          cmd_force_checksrc = $(CHECK) $(CHECKFLAGS) $(c_flags) $< ;
  else
      quiet_cmd_checksrc     = CHECK   $<
            cmd_checksrc     = $(CHECK) $(CHECKFLAGS) $(c_flags) $< ;
  endif
endif

CHECK		= sparse

CHECKFLAGS     := -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ \
		  -Wbitwise -Wno-return-void -D__CHECK_ENDIAN__ $(CF)
CF = 

c_flags := $(KBUILD_CFLAGS) $(cpp_flags)

# ----------------------
if_changed_rule = $(if $(strip $(any-prereq) $(arg-check) ),                 \
	@set -e;                                                             \
	$(rule_$(1)))
# set -e的作用是告诉BASH Shell当生成依赖文件的过程中出现任何错误时，就直接退出，不然还会继续执行下去

any-prereq = $(filter-out $(PHONY),$?) $(filter-out $(PHONY) $(wildcard $^),$^)         所有比目标新的依赖目标的集合
# $? 所有比目标新的依赖目标的集合。以空格分隔。

ifneq ($(KBUILD_NOCMDDEP),1)
# Check if both arguments has same arguments. Result is empty string if equal.
# User may override this check using make KBUILD_NOCMDDEP=1
arg-check = $(strip $(filter-out $(cmd_$(1)), $(cmd_$@)) \
                    $(filter-out $(cmd_$@),   $(cmd_$(1))) )
else
arg-check = $(if $(strip $(cmd_$@)),,1)
endif

rule_cc_o_c
define rule_cc_o_c
	$(call echo-cmd,checksrc) $(cmd_checksrc)			  \                      打印命令，并分析源码
	$(call echo-cmd,cc_o_c) $(cmd_cc_o_c);				  \                      打印命令，并编译目标，-c 只编译不连接
	$(cmd_modversions)						  \                                  添加符号链接
	$(call echo-cmd,record_mcount)					  \
	$(cmd_record_mcount)						  \
	scripts/basic/fixdep $(depfile) $@ '$(call make-cmd,cc_o_c)' >    \
	                                              $(dot-target).tmp;  \
	rm -f $(depfile);						  \
	mv -f $(dot-target).tmp $(dot-target).cmd
endef

# ---------------------
if_changed = $(if $(strip $(any-prereq) $(arg-check)),                       \     # 不分析依赖
	@set -e;                                                             \
	$(echo-cmd) $(cmd_$(1));                                             \
	printf '%s\n' 'cmd_$@ := $(make-cmd)' > $(dot-target).cmd)

# Execute the command and also postprocess generated .d dependencies file.
if_changed_dep = $(if $(strip $(any-prereq) $(arg-check) ),                  \     # 分析依赖
	@set -e;                                                             \
	$(echo-cmd) $(cmd_$(1));                                             \
	scripts/basic/fixdep $(depfile) $@ '$(make-cmd)' > $(dot-target).tmp;\
	rm -f $(depfile);                                                    \
	mv -f $(dot-target).tmp $(dot-target).cmd)

# Usage: $(call if_changed_rule,foo)
# Will check if $(cmd_foo) or any of the prerequisites changed,
# and if so will execute $(rule_foo).
if_changed_rule = $(if $(strip $(any-prereq) $(arg-check) ),                 \      # rule 编译文件
	@set -e;                                                             \
	$(rule_$(1)))


# ---------------------
ifdef builtin-target
quiet_cmd_link_o_target = LD      $@
# If the list of objects to link is empty, just create an empty built-in.o
cmd_link_o_target = $(if $(strip $(obj-y)),\
		      $(LD) $(ld_flags) -r -o $@ $(filter $(obj-y), $^) \                    # 所有 obj-y 链接产生 builtin-target/build-in.o
		      $(cmd_secanalysis),\
		      rm -f $@; $(AR) rcs$(KBUILD_ARFLAGS) $@)

$(builtin-target): $(obj-y) FORCE
	$(call if_changed,link_o_target)

targets += $(builtin-target)
endif # builtin-target





# --------------------
ifdef lib-target
quiet_cmd_link_l_target = AR      $@
cmd_link_l_target = rm -f $@; $(AR) rcs$(KBUILD_ARFLAGS) $@ $(lib-y)

$(lib-target): $(lib-y) FORCE
	$(call if_changed,link_l_target)

targets += $(lib-target)
endif



# =============================================
# 以下两个目标什么也不执行
outputmakefile:
ifneq ($(KBUILD_SRC),)
	$(Q)ln -fsn $(srctree) source
	$(Q)$(CONFIG_SHELL) $(srctree)/scripts/mkmakefile \
	    $(srctree) $(objtree) $(VERSION) $(PATCHLEVEL)
endif

FORCE:

# =============================================
%_defconfig: $(obj)/conf
	$(Q)$< $(silent) --defconfig=arch/$(SRCARCH)/configs/$@ $(Kconfig)

# Added for U-Boot (backward compatibility)
%_config: %_defconfig
	@:

%_defconfig: $(obj)/conf
	$(Q)$< $(silent) --defconfig=arch/$(SRCARCH)/configs/$@ $(Kconfig)
	= $(Q)$(obj)/conf $(silent) --defconfig=arch/$(SRCARCH)/configs/$@ $(Kconfig)
	=conf -s --defconfig=arch/arm/configs/xxx_config $(Kconfig)
	=conf -s --defconfig=arch/arm/configs/xxx_config Kconfig	


$(obj)/conf:                                                                                通过 hostprog 编译链接出来的

hostprogs-y := conf nconf mconf kxgettext qconf gconf
__hostprogs := $(sort $(hostprogs-y) $(hostprogs-m))
			= $(sort $(hostprogs-y))

conf-objs	:= conf.o  zconf.tab.o                                                          来源于 conf.c  zconf.tab.c .....文件







	defconfig_file = optarg;
	defconfig_file = arch/arm/configs/xxx_config;
	
	conf_parse(name)
	=conf_parse(Kconfig)																	11111
	
	conf_read(defconfig_file)
	=conf_read(arch/arm/configs/xxx_config)													22222
	
	conf_set_all_new_symbols(def_default)                                                   33333
	
	conf_write(NULL)                                                                        44444
	argv[0]为空，就写入.config 中，不为空写入 KCONFIG_CONFIG 中
	
	
conf通过conf_parse(Kconfig);来解析可选的配置信息，保存到一个链表中。
随后通过conf_read(rpi_defconfig)读取默认的设置文件,并且生成新的配置文件
调用conf_set_all_new_symbols更新关系链表
最后调用conf_write写入到.config中

11111:
	打开根目录下的 ${SRCTREE}/Kconfig 文件，只读方式打开
	添加 utstime  sym
	初始化 menu
22222:
	读取配置文件，生成新的配置文件
33333:
	删除没用项，更新配置文件
44444:
	获取输出文件名字，全部设置写入文件中
	














































