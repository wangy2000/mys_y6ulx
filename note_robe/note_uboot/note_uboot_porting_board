board_early_init_f                                                                           // 初始化 uart1 两个 pin 脚
	main -> board_init_f
	
board_init	                                                                                 // 初始化了 boot_mode[1:0], temper7, temper8 四个 pin 脚， 用于初始化 iox74lv_init
	main -> board_init_f / board_init_r(init_sequence_r)                                     // 设置 sdram 基地址，初始化 i2c，fec，usb_otg，qspi，gpmi_nand
	
board_late_init                                                                              // 添加 boot_mode，设置 mmc dev 1 命令，并运行，复位看门狗
	main -> board_init_f / board_init_r(init_sequence_r)
	
	

	
// ==========================  board_early_init_f 详细分析
(uboot\board\myir\mys_imx6ull\mys_imx6ull.c)

int board_early_init_f(void)
{
	setup_iomux_uart();

	return 0;
}

static void setup_iomux_uart(void)
{
	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));                   // 从 64 位数据数组中解析出来寄存器偏移 和 寄存器的数据
}                                                                                           // 基于 base 地址的偏移找到寄存器，写入寄存器数据

(uboot\arch\arm\imx-common\iomux-v3.c)

void imx_iomux_v3_setup_multiple_pads(iomux_v3_cfg_t const *pad_list,
				      unsigned count)
{
	iomux_v3_cfg_t const *p = pad_list;
	int stride;
	int i;

#if defined(CONFIG_MX6QDL)
	stride = 2;
	if (!is_cpu_type(MXC_CPU_MX6Q) && !is_cpu_type(MXC_CPU_MX6D))
		p += 1;
#else
	stride = 1;
#endif
	for (i = 0; i < count; i++) {
		imx_iomux_v3_setup_pad(*p);
		p += stride;
	}
}

void imx_iomux_v3_setup_pad(iomux_v3_cfg_t pad)                             // 设置 pads
{
	u32 mux_ctrl_ofs = (pad & MUX_CTRL_OFS_MASK) >> MUX_CTRL_OFS_SHIFT;     // 0xfff << 0
	u32 mux_mode = (pad & MUX_MODE_MASK) >> MUX_MODE_SHIFT;                 // 0x3f  << 36
	u32 sel_input_ofs =
		(pad & MUX_SEL_INPUT_OFS_MASK) >> MUX_SEL_INPUT_OFS_SHIFT;          // 0xfff << 24
	u32 sel_input =
		(pad & MUX_SEL_INPUT_MASK) >> MUX_SEL_INPUT_SHIFT;                  // 0xf   << 60
	u32 pad_ctrl_ofs =
		(pad & MUX_PAD_CTRL_OFS_MASK) >> MUX_PAD_CTRL_OFS_SHIFT;            // 0xfff  << 12
	u32 pad_ctrl = (pad & MUX_PAD_CTRL_MASK) >> MUX_PAD_CTRL_SHIFT;         // 0x3ffff << 42

#if defined CONFIG_MX6SL
	/* Check whether LVE bit needs to be set */
	if (pad_ctrl & PAD_CTL_LVE) {
		pad_ctrl &= ~PAD_CTL_LVE;
		pad_ctrl |= PAD_CTL_LVE_BIT;
	}
#endif

#ifdef CONFIG_IOMUX_LPSR
	u32 lpsr = (pad & MUX_MODE_LPSR) >> MUX_MODE_SHIFT;

#ifdef CONFIG_MX7
	if (lpsr == IOMUX_CONFIG_LPSR) {
		base = (void *)IOMUXC_LPSR_BASE_ADDR;
		mux_mode &= ~IOMUX_CONFIG_LPSR;
		/* set daisy chain sel_input */
		if (sel_input_ofs)
			sel_input_ofs += IOMUX_LPSR_SEL_INPUT_OFS;
	}
#else
	if (is_cpu_type(MXC_CPU_MX6ULL)) {
		if (lpsr == IOMUX_CONFIG_LPSR) {
			base = (void *)IOMUXC_SNVS_BASE_ADDR;
			mux_mode &= ~IOMUX_CONFIG_LPSR;
		}
	}
#endif
#endif

	if (is_soc_type(MXC_SOC_MX7) || is_cpu_type(MXC_CPU_MX6ULL) || mux_ctrl_ofs)
		__raw_writel(mux_mode, base + mux_ctrl_ofs);

	if (sel_input_ofs)
		__raw_writel(sel_input, base + sel_input_ofs);

#ifdef CONFIG_IOMUX_SHARE_CONF_REG
	if (!(pad_ctrl & NO_PAD_CTRL))
		__raw_writel((mux_mode << PAD_MUX_MODE_SHIFT) | pad_ctrl,
			base + pad_ctrl_ofs);
#else
	if (!(pad_ctrl & NO_PAD_CTRL) && pad_ctrl_ofs)
		__raw_writel(pad_ctrl, base + pad_ctrl_ofs);
#endif

#ifdef CONFIG_IOMUX_LPSR
	if (lpsr == IOMUX_CONFIG_LPSR)
		base = (void *)IOMUXC_BASE_ADDR;
#endif

}

// =======================  pad 配置解析
static iomux_v3_cfg_t const uart1_pads[] = {                                                         // pads 实质是定义了一个 64 位的数据数组。
	MX6_PAD_UART1_TX_DATA__UART1_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
	MX6_PAD_UART1_RX_DATA__UART1_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
};

MX6_PAD_UART1_TX_DATA__UART1_DCE_TX = IOMUX_PAD(0x0310, 0x0084, 0, 0x0000, 0, 0),

#define IOMUX_PAD(pad_ctrl_ofs, mux_ctrl_ofs, mux_mode, sel_input_ofs, sel_input, pad_ctrl) \    
	(((iomux_v3_cfg_t)(mux_ctrl_ofs) << MUX_CTRL_OFS_SHIFT)     |	\                                  mux_ctrl_ofs  << 0 
	((iomux_v3_cfg_t)(mux_mode)      << MUX_MODE_SHIFT)         |	\                                  mux_mode      << 36
	((iomux_v3_cfg_t)(pad_ctrl_ofs)  << MUX_PAD_CTRL_OFS_SHIFT) |	\                                  pad_ctrl_ofs  << 12
	((iomux_v3_cfg_t)(pad_ctrl)      << MUX_PAD_CTRL_SHIFT)     |	\                                  pad_ctrl      << 42
	((iomux_v3_cfg_t)(sel_input_ofs) << MUX_SEL_INPUT_OFS_SHIFT)|	\                                  sel_input_ofs << 24
	((iomux_v3_cfg_t)(sel_input)     << MUX_SEL_INPUT_SHIFT))                                          sel_input     << 60

MUX_PAD_CTRL(UART_PAD_CTRL)

#define UART_PAD_CTRL    \                                                                             
	(PAD_CTL_PKE |      \                                                              1 << 12
	PAD_CTL_PUE |		\                                                              1 << 13 | PAD_CTL_PKE
	PAD_CTL_PUS_100K_UP | \                                                            2 << 14 | PAD_CTL_PUE
	PAD_CTL_SPEED_MED |	  \                                                            2 << 6
	PAD_CTL_DSE_40ohm   | \                                                            6 << 3
	PAD_CTL_SRE_FAST  |   \                                                            1 << 0
	PAD_CTL_HYS)                                                                       1 << 16

#define MUX_PAD_CTRL(x)		((iomux_v3_cfg_t)(x) << MUX_PAD_CTRL_SHIFT)


// ==========================  board_init 详细分析
(uboot\board\myir\mys_imx6ull\mys_imx6ull.c)

int board_init(void)
{
	/* Address of boot parameters */
	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;                                      // 设置 sdram 基地址

	imx_iomux_v3_setup_multiple_pads(iox_pads, ARRAY_SIZE(iox_pads));               

	iox74lv_init();                                                                   // 初始化了 boot_mode[1:0], temper7, temper8 四个 pin 脚， 用于初始化 iox74lv_init

#ifdef CONFIG_SYS_I2C_MXC
	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);                         // i2c，gpio_request, enable clock, 初始化 gpio，初始化 i2c
#endif

#ifdef	CONFIG_FEC_MXC
	setup_fec(CONFIG_FEC_ENET_DEV);                                                   // fec，设置网络时钟，使能时钟
#endif

#ifdef CONFIG_USB_EHCI_MX6
	setup_usb();                                                                      // usb_otg，设置 otg pin脚
#endif

#ifdef CONFIG_FSL_QSPI
	board_qspi_init();                                                                // qspi，设置 pin 脚，使能时钟
#endif

#ifdef CONFIG_NAND_MXS
	setup_gpmi_nand();                                                                // gpmi_nand, 设置 pin 脚，设置时钟，使能时钟
#endif

	return 0;
}


// ==========================  board_late_init 详细分析
(uboot\board\myir\mys_imx6ull\mys_imx6ull.c)

int board_late_init(void)
{
#ifdef CONFIG_CMD_BMODE
	add_board_boot_modes(board_boot_modes);                                          // 添加 boot_mode
#endif

#ifdef CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
	setenv("board_name", "MYS6ULL");

	if (is_mx6ull_9x9_evk())
		setenv("board_rev", "9X9");
	else
		setenv("board_rev", "14X14");
#endif

#ifdef CONFIG_ENV_IS_IN_MMC
	board_late_mmc_env_init();                                                       // 设置 mmc dev 1 命令，并运行
#endif

	set_wdog_reset((struct wdog_regs *)WDOG1_BASE_ADDR);                             // 复位看门狗

	return 0;
}

void add_board_boot_modes(const struct boot_mode *p)
{
	int size;
	char *dest;

	cmd_tbl_t *entry = ll_entry_get(cmd_tbl_t, bmode, cmd);

	if (entry->usage) {
		free(entry->usage);
		entry->usage = NULL;
	}

	modes[0] = p;
	modes[1] = soc_boot_modes;
	size = create_usage(NULL);
	dest = malloc(size);
	if (dest) {
		create_usage(dest);
		entry->usage = dest;
	}
}	
	
#define ll_entry_get(_type, _name, _list)				\
({								\
	extern _type _u_boot_list_2_##_list##_2_##_name;	\
	_type *_ll_result =					\
		&_u_boot_list_2_##_list##_2_##_name;		\
	_ll_result;						\
})

ll_entry_get(_type, _name, _list)
= extern  _type  _u_boot_list_2_##_list##_2_##_name;
  _type *_ll_result = &_u_boot_list_2_##_list##_2_##_name;
  _ll_result;

static const struct boot_mode board_boot_modes[] = {
	/* 4 bit bus width */
	{"sd1", MAKE_CFGVAL(0x42, 0x20, 0x00, 0x00)},
	{"sd2", MAKE_CFGVAL(0x40, 0x28, 0x00, 0x00)},
	{"qspi1", MAKE_CFGVAL(0x10, 0x00, 0x00, 0x00)},
	{NULL,	 0},
};

const struct boot_mode soc_boot_modes[] = {
	{"normal",	MAKE_CFGVAL(0x00, 0x00, 0x00, 0x00)},
	/* reserved value should start rom usb */
	{"usb",		MAKE_CFGVAL(0x01, 0x00, 0x00, 0x00)},
	{"sata",	MAKE_CFGVAL(0x20, 0x00, 0x00, 0x00)},
	{"ecspi1:0",	MAKE_CFGVAL(0x30, 0x00, 0x00, 0x08)},
	{"ecspi1:1",	MAKE_CFGVAL(0x30, 0x00, 0x00, 0x18)},
	{"ecspi1:2",	MAKE_CFGVAL(0x30, 0x00, 0x00, 0x28)},
	{"ecspi1:3",	MAKE_CFGVAL(0x30, 0x00, 0x00, 0x38)},
	/* 4 bit bus width */
	{"esdhc1",	MAKE_CFGVAL(0x40, 0x20, 0x00, 0x00)},
	{"esdhc2",	MAKE_CFGVAL(0x40, 0x28, 0x00, 0x00)},
	{"esdhc3",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
	{"esdhc4",	MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
	{NULL,		0},
};